package main

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

func main() {
	out, err := exec.Command("go", "env", "GOROOT").Output()
	if err != nil {
		log.Fatalf("Failed to get GOROOT")
	}

	zsysnumFile := filepath.Join(strings.TrimSpace(string(out)), "src/syscall/zsysnum_linux_amd64.go")
	fd, err := os.Open(zsysnumFile)
	if err != nil {
		log.Fatalf("Failed to open sysnum file: %v", err)
	}
	defer fd.Close()

	var buf bytes.Buffer
	fmt.Fprintf(&buf, `// generated by ./gogen/main.go; DO NOT EDIT

package main

var (
	syscallsNum2name = map[int]string{}
	syscallsName2num = map[string]int{}
)

func init() {
`)

	scanner := bufio.NewScanner(fd)
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)

		if !strings.HasPrefix(line, "SYS_") {
			continue
		}

		a, b, ok := strings.Cut(line, "=")
		if !ok {
			continue
		}

		syscallName := strings.ToLower(a[4:])
		syscallName, b = strings.TrimSpace(syscallName), strings.TrimSpace(b)
		fmt.Fprintf(&buf, "\tsyscallsNum2name[%s] = \"%s\"\n", b, syscallName)
		fmt.Fprintf(&buf, "\tsyscallsName2num[\"%s\"] = %s\n", syscallName, b)
	}

	if err := scanner.Err(); err != nil {
		log.Fatalf("Failed to scan: %v", err)
	}

	fmt.Fprintf(&buf, "}\n")

	outFile := os.Args[1]
	fd, err = os.OpenFile(outFile, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
	if err != nil {
		log.Fatalf("Failed to open output file: %v", err)
	}
	defer fd.Close()

	_, err = fd.Write(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to write to output file: %v", err)
	}
}
